{"ast":null,"code":"'use strict';\n\nconst MiniPass = require('minipass');\n\nconst EE = require('events').EventEmitter;\n\nconst fs = require('fs'); // for writev\n\n\nconst binding = process.binding('fs');\nconst writeBuffers = binding.writeBuffers;\n/* istanbul ignore next */\n\nconst FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;\n\nconst _autoClose = Symbol('_autoClose');\n\nconst _close = Symbol('_close');\n\nconst _ended = Symbol('_ended');\n\nconst _fd = Symbol('_fd');\n\nconst _finished = Symbol('_finished');\n\nconst _flags = Symbol('_flags');\n\nconst _flush = Symbol('_flush');\n\nconst _handleChunk = Symbol('_handleChunk');\n\nconst _makeBuf = Symbol('_makeBuf');\n\nconst _mode = Symbol('_mode');\n\nconst _needDrain = Symbol('_needDrain');\n\nconst _onerror = Symbol('_onerror');\n\nconst _onopen = Symbol('_onopen');\n\nconst _onread = Symbol('_onread');\n\nconst _onwrite = Symbol('_onwrite');\n\nconst _open = Symbol('_open');\n\nconst _path = Symbol('_path');\n\nconst _pos = Symbol('_pos');\n\nconst _queue = Symbol('_queue');\n\nconst _read = Symbol('_read');\n\nconst _readSize = Symbol('_readSize');\n\nconst _reading = Symbol('_reading');\n\nconst _remain = Symbol('_remain');\n\nconst _size = Symbol('_size');\n\nconst _write = Symbol('_write');\n\nconst _writing = Symbol('_writing');\n\nconst _defaultFlag = Symbol('_defaultFlag');\n\nclass ReadStream extends MiniPass {\n  constructor(path, opt) {\n    opt = opt || {};\n    super(opt);\n    this.writable = false;\n    if (typeof path !== 'string') throw new TypeError('path must be a string');\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null;\n    this[_path] = path;\n    this[_readSize] = opt.readSize || 16 * 1024 * 1024;\n    this[_reading] = false;\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;\n    this[_remain] = this[_size];\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n    if (typeof this[_fd] === 'number') this[_read]();else this[_open]();\n  }\n\n  get fd() {\n    return this[_fd];\n  }\n\n  get path() {\n    return this[_path];\n  }\n\n  write() {\n    throw new TypeError('this is a readable stream');\n  }\n\n  end() {\n    throw new TypeError('this is a readable stream');\n  }\n\n  [_open]() {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd));\n  }\n\n  [_onopen](er, fd) {\n    if (er) this[_onerror](er);else {\n      this[_fd] = fd;\n      this.emit('open', fd);\n\n      this[_read]();\n    }\n  }\n\n  [_makeBuf]() {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));\n  }\n\n  [_read]() {\n    if (!this[_reading]) {\n      this[_reading] = true;\n\n      const buf = this[_makeBuf]();\n      /* istanbul ignore if */\n\n\n      if (buf.length === 0) return process.nextTick(() => this[_onread](null, 0, buf));\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) => this[_onread](er, br, buf));\n    }\n  }\n\n  [_onread](er, br, buf) {\n    this[_reading] = false;\n    if (er) this[_onerror](er);else if (this[_handleChunk](br, buf)) this[_read]();\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'));\n      this[_fd] = null;\n    }\n  }\n\n  [_onerror](er) {\n    this[_reading] = true;\n\n    this[_close]();\n\n    this.emit('error', er);\n  }\n\n  [_handleChunk](br, buf) {\n    let ret = false; // no effect if infinite\n\n    this[_remain] -= br;\n    if (br > 0) ret = super.write(br < buf.length ? buf.slice(0, br) : buf);\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false;\n\n      this[_close]();\n\n      super.end();\n    }\n\n    return ret;\n  }\n\n  emit(ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break;\n\n      case 'drain':\n        if (typeof this[_fd] === 'number') this[_read]();\n        break;\n\n      default:\n        return super.emit(ev, data);\n    }\n  }\n\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open]() {\n    let threw = true;\n\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'));\n\n      threw = false;\n    } finally {\n      if (threw) this[_close]();\n    }\n  }\n\n  [_read]() {\n    let threw = true;\n\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true;\n\n        do {\n          const buf = this[_makeBuf]();\n          /* istanbul ignore next */\n\n\n          const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null);\n          if (!this[_handleChunk](br, buf)) break;\n        } while (true);\n\n        this[_reading] = false;\n      }\n\n      threw = false;\n    } finally {\n      if (threw) this[_close]();\n    }\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd]);\n      } catch (er) {}\n\n      this[_fd] = null;\n      this.emit('close');\n    }\n  }\n\n}\n\nclass WriteStream extends EE {\n  constructor(path, opt) {\n    opt = opt || {};\n    super(opt);\n    this.readable = false;\n    this[_writing] = false;\n    this[_ended] = false;\n    this[_needDrain] = false;\n    this[_queue] = [];\n    this[_path] = path;\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null;\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode;\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null;\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true; // truncating makes no sense when writing into the middle\n\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w';\n    this[_defaultFlag] = opt.flags === undefined;\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;\n    if (this[_fd] === null) this[_open]();\n  }\n\n  get fd() {\n    return this[_fd];\n  }\n\n  get path() {\n    return this[_path];\n  }\n\n  [_onerror](er) {\n    this[_close]();\n\n    this[_writing] = true;\n    this.emit('error', er);\n  }\n\n  [_open]() {\n    fs.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));\n  }\n\n  [_onopen](er, fd) {\n    if (this[_defaultFlag] && this[_flags] === 'r+' && er && er.code === 'ENOENT') {\n      this[_flags] = 'w';\n\n      this[_open]();\n    } else if (er) this[_onerror](er);else {\n      this[_fd] = fd;\n      this.emit('open', fd);\n\n      this[_flush]();\n    }\n  }\n\n  end(buf, enc) {\n    if (buf) this.write(buf, enc);\n    this[_ended] = true; // synthetic after-write logic, where drain/finish live\n\n    if (!this[_writing] && !this[_queue].length && typeof this[_fd] === 'number') this[_onwrite](null, 0);\n  }\n\n  write(buf, enc) {\n    if (typeof buf === 'string') buf = new Buffer(buf, enc);\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'));\n      return false;\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf);\n\n      this[_needDrain] = true;\n      return false;\n    }\n\n    this[_writing] = true;\n\n    this[_write](buf);\n\n    return true;\n  }\n\n  [_write](buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));\n  }\n\n  [_onwrite](er, bw) {\n    if (er) this[_onerror](er);else {\n      if (this[_pos] !== null) this[_pos] += bw;\n      if (this[_queue].length) this[_flush]();else {\n        this[_writing] = false;\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true;\n\n          this[_close]();\n\n          this.emit('finish');\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false;\n          this.emit('drain');\n        }\n      }\n    }\n  }\n\n  [_flush]() {\n    if (this[_queue].length === 0) {\n      if (this[_ended]) this[_onwrite](null, 0);\n    } else if (this[_queue].length === 1) this[_write](this[_queue].pop());else {\n      const iovec = this[_queue];\n      this[_queue] = [];\n      writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));\n    }\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'));\n      this[_fd] = null;\n    }\n  }\n\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open]() {\n    let fd;\n\n    try {\n      fd = fs.openSync(this[_path], this[_flags], this[_mode]);\n    } catch (er) {\n      if (this[_defaultFlag] && this[_flags] === 'r+' && er && er.code === 'ENOENT') {\n        this[_flags] = 'w';\n        return this[_open]();\n      } else throw er;\n    }\n\n    this[_onopen](null, fd);\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd]);\n      } catch (er) {}\n\n      this[_fd] = null;\n      this.emit('close');\n    }\n  }\n\n  [_write](buf) {\n    try {\n      this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));\n    } catch (er) {\n      this[_onwrite](er, 0);\n    }\n  }\n\n}\n\nconst writev = (fd, iovec, pos, cb) => {\n  const done = (er, bw) => cb(er, bw, iovec);\n\n  const req = new FSReqWrap();\n  req.oncomplete = done;\n  binding.writeBuffers(fd, iovec, pos, req);\n};\n\nexports.ReadStream = ReadStream;\nexports.ReadStreamSync = ReadStreamSync;\nexports.WriteStream = WriteStream;\nexports.WriteStreamSync = WriteStreamSync;","map":null,"metadata":{},"sourceType":"script"}