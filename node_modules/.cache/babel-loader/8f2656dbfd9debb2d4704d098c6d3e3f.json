{"ast":null,"code":"'use strict';\n\nconst Buffer = require('./buffer.js');\n\nconst MiniPass = require('minipass');\n\nconst Pax = require('./pax.js');\n\nconst Header = require('./header.js');\n\nconst ReadEntry = require('./read-entry.js');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst types = require('./types.js');\n\nconst maxReadSize = 16 * 1024 * 1024;\nconst PROCESS = Symbol('process');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst HEADER = Symbol('header');\nconst READ = Symbol('read');\nconst LSTAT = Symbol('lstat');\nconst ONLSTAT = Symbol('onlstat');\nconst ONREAD = Symbol('onread');\nconst ONREADLINK = Symbol('onreadlink');\nconst OPENFILE = Symbol('openfile');\nconst ONOPENFILE = Symbol('onopenfile');\nconst CLOSE = Symbol('close');\nconst MODE = Symbol('mode');\n\nconst warner = require('./warn-mixin.js');\n\nconst winchars = require('./winchars.js');\n\nconst modeFix = require('./mode-fix.js');\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor(p, opt) {\n    opt = opt || {};\n    super(opt);\n    if (typeof p !== 'string') throw new TypeError('path is required');\n    this.path = p; // suppress atime, ctime, uid, gid, uname, gname\n\n    this.portable = !!opt.portable; // until node has builtin pwnam functions, this'll have to do\n\n    this.myuid = process.getuid && process.getuid();\n    this.myuser = process.env.USER || '';\n    this.maxReadSize = opt.maxReadSize || maxReadSize;\n    this.linkCache = opt.linkCache || new Map();\n    this.statCache = opt.statCache || new Map();\n    this.preservePaths = !!opt.preservePaths;\n    this.cwd = opt.cwd || process.cwd();\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.noMtime = !!opt.noMtime;\n    this.mtime = opt.mtime || null;\n    if (typeof opt.onwarn === 'function') this.on('warn', opt.onwarn);\n\n    if (!this.preservePaths && path.win32.isAbsolute(p)) {\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      const parsed = path.win32.parse(p);\n      this.warn('stripping ' + parsed.root + ' from absolute path', p);\n      this.path = p.substr(parsed.root.length);\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32';\n\n    if (this.win32) {\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'));\n      p = p.replace(/\\\\/g, '/');\n    }\n\n    this.absolute = opt.absolute || path.resolve(this.cwd, p);\n    if (this.path === '') this.path = './';\n    if (this.statCache.has(this.absolute)) this[ONLSTAT](this.statCache.get(this.absolute));else this[LSTAT]();\n  }\n\n  [LSTAT]() {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) return this.emit('error', er);\n      this[ONLSTAT](stat);\n    });\n  }\n\n  [ONLSTAT](stat) {\n    this.statCache.set(this.absolute, stat);\n    this.stat = stat;\n    if (!stat.isFile()) stat.size = 0;\n    this.type = getType(stat);\n    this.emit('stat', stat);\n    this[PROCESS]();\n  }\n\n  [PROCESS]() {\n    switch (this.type) {\n      case 'File':\n        return this[FILE]();\n\n      case 'Directory':\n        return this[DIRECTORY]();\n\n      case 'SymbolicLink':\n        return this[SYMLINK]();\n      // unsupported types are ignored.\n\n      default:\n        return this.end();\n    }\n  }\n\n  [MODE](mode) {\n    return modeFix(mode, this.type === 'Directory');\n  }\n\n  [HEADER]() {\n    if (this.type === 'Directory' && this.portable) this.noMtime = true;\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime\n    });\n    if (this.header.encode() && !this.noPax) this.write(new Pax({\n      atime: this.portable ? null : this.header.atime,\n      ctime: this.portable ? null : this.header.ctime,\n      gid: this.portable ? null : this.header.gid,\n      mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n      path: this.path,\n      linkpath: this.linkpath,\n      size: this.header.size,\n      uid: this.portable ? null : this.header.uid,\n      uname: this.portable ? null : this.header.uname,\n      dev: this.portable ? null : this.stat.dev,\n      ino: this.portable ? null : this.stat.ino,\n      nlink: this.portable ? null : this.stat.nlink\n    }).encode());\n    this.write(this.header.block);\n  }\n\n  [DIRECTORY]() {\n    if (this.path.substr(-1) !== '/') this.path += '/';\n    this.stat.size = 0;\n    this[HEADER]();\n    this.end();\n  }\n\n  [SYMLINK]() {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) return this.emit('error', er);\n      this[ONREADLINK](linkpath);\n    });\n  }\n\n  [ONREADLINK](linkpath) {\n    this.linkpath = linkpath;\n    this[HEADER]();\n    this.end();\n  }\n\n  [HARDLINK](linkpath) {\n    this.type = 'Link';\n    this.linkpath = path.relative(this.cwd, linkpath);\n    this.stat.size = 0;\n    this[HEADER]();\n    this.end();\n  }\n\n  [FILE]() {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino;\n\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey);\n        if (linkpath.indexOf(this.cwd) === 0) return this[HARDLINK](linkpath);\n      }\n\n      this.linkCache.set(linkKey, this.absolute);\n    }\n\n    this[HEADER]();\n    if (this.stat.size === 0) return this.end();\n    this[OPENFILE]();\n  }\n\n  [OPENFILE]() {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) return this.emit('error', er);\n      this[ONOPENFILE](fd);\n    });\n  }\n\n  [ONOPENFILE](fd) {\n    const blockLen = 512 * Math.ceil(this.stat.size / 512);\n    const bufLen = Math.min(blockLen, this.maxReadSize);\n    const buf = Buffer.allocUnsafe(bufLen);\n    this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen);\n  }\n\n  [READ](fd, buf, offset, length, pos, remain, blockRemain) {\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) return this[CLOSE](fd, _ => this.emit('error', er));\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);\n    });\n  }\n\n  [CLOSE](fd, cb) {\n    fs.close(fd, cb);\n  }\n\n  [ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {\n    if (bytesRead <= 0 && remain > 0) {\n      const er = new Error('encountered unexpected EOF');\n      er.path = this.absolute;\n      er.syscall = 'read';\n      er.code = 'EOF';\n      this[CLOSE](fd, _ => _);\n      return this.emit('error', er);\n    }\n\n    if (bytesRead > remain) {\n      const er = new Error('did not encounter expected EOF');\n      er.path = this.absolute;\n      er.syscall = 'read';\n      er.code = 'EOF';\n      this[CLOSE](fd, _ => _);\n      return this.emit('error', er);\n    } // null out the rest of the buffer, if we could fit the block padding\n\n\n    if (bytesRead === remain) {\n      for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {\n        buf[i + offset] = 0;\n        bytesRead++;\n        remain++;\n      }\n    }\n\n    const writeBuf = offset === 0 && bytesRead === buf.length ? buf : buf.slice(offset, offset + bytesRead);\n    remain -= bytesRead;\n    blockRemain -= bytesRead;\n    pos += bytesRead;\n    offset += bytesRead;\n    this.write(writeBuf);\n\n    if (!remain) {\n      if (blockRemain) this.write(Buffer.alloc(blockRemain));\n      this.end();\n      this[CLOSE](fd, _ => _);\n      return;\n    }\n\n    if (offset >= length) {\n      buf = Buffer.allocUnsafe(length);\n      offset = 0;\n    }\n\n    length = buf.length - offset;\n    this[READ](fd, buf, offset, length, pos, remain, blockRemain);\n  }\n\n});\n\nclass WriteEntrySync extends WriteEntry {\n  constructor(path, opt) {\n    super(path, opt);\n  }\n\n  [LSTAT]() {\n    this[ONLSTAT](fs.lstatSync(this.absolute));\n  }\n\n  [SYMLINK]() {\n    this[ONREADLINK](fs.readlinkSync(this.absolute));\n  }\n\n  [OPENFILE]() {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'));\n  }\n\n  [READ](fd, buf, offset, length, pos, remain, blockRemain) {\n    let threw = true;\n\n    try {\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos);\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);\n      threw = false;\n    } finally {\n      if (threw) try {\n        this[CLOSE](fd);\n      } catch (er) {}\n    }\n  }\n\n  [CLOSE](fd) {\n    fs.closeSync(fd);\n  }\n\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor(readEntry, opt) {\n    opt = opt || {};\n    super(opt);\n    this.preservePaths = !!opt.preservePaths;\n    this.portable = !!opt.portable;\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.noMtime = !!opt.noMtime;\n    this.readEntry = readEntry;\n    this.type = readEntry.type;\n    if (this.type === 'Directory' && this.portable) this.noMtime = true;\n    this.path = readEntry.path;\n    this.mode = this[MODE](readEntry.mode);\n    this.uid = this.portable ? null : readEntry.uid;\n    this.gid = this.portable ? null : readEntry.gid;\n    this.uname = this.portable ? null : readEntry.uname;\n    this.gname = this.portable ? null : readEntry.gname;\n    this.size = readEntry.size;\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;\n    this.atime = this.portable ? null : readEntry.atime;\n    this.ctime = this.portable ? null : readEntry.ctime;\n    this.linkpath = readEntry.linkpath;\n    if (typeof opt.onwarn === 'function') this.on('warn', opt.onwarn);\n\n    if (path.isAbsolute(this.path) && !this.preservePaths) {\n      const parsed = path.parse(this.path);\n      this.warn('stripping ' + parsed.root + ' from absolute path', this.path);\n      this.path = this.path.substr(parsed.root.length);\n    }\n\n    this.remain = readEntry.size;\n    this.blockRemain = readEntry.startBlockSize;\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime\n    });\n    if (this.header.encode() && !this.noPax) super.write(new Pax({\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime,\n      gid: this.portable ? null : this.gid,\n      mtime: this.noMtime ? null : this.mtime,\n      path: this.path,\n      linkpath: this.linkpath,\n      size: this.size,\n      uid: this.portable ? null : this.uid,\n      uname: this.portable ? null : this.uname,\n      dev: this.portable ? null : this.readEntry.dev,\n      ino: this.portable ? null : this.readEntry.ino,\n      nlink: this.portable ? null : this.readEntry.nlink\n    }).encode());\n    super.write(this.header.block);\n    readEntry.pipe(this);\n  }\n\n  [MODE](mode) {\n    return modeFix(mode, this.type === 'Directory');\n  }\n\n  write(data) {\n    const writeLen = data.length;\n    if (writeLen > this.blockRemain) throw new Error('writing more to entry than is appropriate');\n    this.blockRemain -= writeLen;\n    return super.write(data);\n  }\n\n  end() {\n    if (this.blockRemain) this.write(Buffer.alloc(this.blockRemain));\n    return super.end();\n  }\n\n});\nWriteEntry.Sync = WriteEntrySync;\nWriteEntry.Tar = WriteEntryTar;\n\nconst getType = stat => stat.isFile() ? 'File' : stat.isDirectory() ? 'Directory' : stat.isSymbolicLink() ? 'SymbolicLink' : 'Unsupported';\n\nmodule.exports = WriteEntry;","map":null,"metadata":{},"sourceType":"script"}