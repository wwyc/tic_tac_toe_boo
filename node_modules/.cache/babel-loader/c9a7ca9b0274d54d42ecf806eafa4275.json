{"ast":null,"code":"'use strict';\n\nconst types = require('./types.js');\n\nconst MiniPass = require('minipass');\n\nconst SLURP = Symbol('slurp');\nmodule.exports = class ReadEntry extends MiniPass {\n  constructor(header, ex, gex) {\n    super(); // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n\n    this.pause();\n    this.extended = ex;\n    this.globalExtended = gex;\n    this.header = header;\n    this.startBlockSize = 512 * Math.ceil(header.size / 512);\n    this.blockRemain = this.startBlockSize;\n    this.remain = header.size;\n    this.type = header.type;\n    this.meta = false;\n    this.ignore = false;\n\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break;\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true;\n        break;\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n\n      default:\n        this.ignore = true;\n    }\n\n    this.path = header.path;\n    this.mode = header.mode;\n    if (this.mode) this.mode = this.mode & 0o7777;\n    this.uid = header.uid;\n    this.gid = header.gid;\n    this.uname = header.uname;\n    this.gname = header.gname;\n    this.size = header.size;\n    this.mtime = header.mtime;\n    this.atime = header.atime;\n    this.ctime = header.ctime;\n    this.linkpath = header.linkpath;\n    this.uname = header.uname;\n    this.gname = header.gname;\n    if (ex) this[SLURP](ex);\n    if (gex) this[SLURP](gex, true);\n  }\n\n  write(data) {\n    const writeLen = data.length;\n    if (writeLen > this.blockRemain) throw new Error('writing more to entry than is appropriate');\n    const r = this.remain;\n    const br = this.blockRemain;\n    this.remain = Math.max(0, r - writeLen);\n    this.blockRemain = Math.max(0, br - writeLen);\n    if (this.ignore) return true;\n    if (r >= writeLen) return super.write(data); // r < writeLen\n\n    return super.write(data.slice(0, r));\n  }\n\n  [SLURP](ex, global) {\n    for (let k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined && !(global && k === 'path')) this[k] = ex[k];\n    }\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}