{"ast":null,"code":"'use strict'; // walk the tree of deps starting from the top level list of bundled deps\n// Any deps at the top level that are depended on by a bundled dep that\n// does not have that dep in its own node_modules folder are considered\n// bundled deps as well.  This list of names can be passed to npm-packlist\n// as the \"bundled\" argument.  Additionally, packageJsonCache is shared so\n// packlist doesn't have to re-read files already consumed in this pass\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst EE = require('events').EventEmitter;\n\nclass BundleWalker extends EE {\n  constructor(opt) {\n    opt = opt || {};\n    super(opt);\n    this.path = path.resolve(opt.path || process.cwd());\n    this.parent = opt.parent || null;\n\n    if (this.parent) {\n      this.result = this.parent.result; // only collect results in node_modules folders at the top level\n      // since the node_modules in a bundled dep is included always\n\n      if (!this.parent.parent) {\n        const base = path.basename(this.path);\n        const scope = path.basename(path.dirname(this.path));\n        this.result.add(/^@/.test(scope) ? scope + '/' + base : base);\n      }\n\n      this.root = this.parent.root;\n      this.packageJsonCache = this.parent.packageJsonCache;\n    } else {\n      this.result = new Set();\n      this.root = this.path;\n      this.packageJsonCache = opt.packageJsonCache || new Map();\n    }\n\n    this.seen = new Set();\n    this.didDone = false;\n    this.children = 0;\n    this.node_modules = [];\n    this.package = null;\n    this.bundle = null;\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn);\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn);\n\n    if (ev === 'done' && this.didDone) {\n      this.emit('done', this.result);\n    }\n\n    return ret;\n  }\n\n  done() {\n    if (!this.didDone) {\n      this.didDone = true;\n\n      if (!this.parent) {\n        const res = Array.from(this.result);\n        this.result = res;\n        this.emit('done', res);\n      } else {\n        this.emit('done');\n      }\n    }\n  }\n\n  start() {\n    const pj = path.resolve(this.path, 'package.json');\n    if (this.packageJsonCache.has(pj)) this.onPackage(this.packageJsonCache.get(pj));else this.readPackageJson(pj);\n    return this;\n  }\n\n  readPackageJson(pj) {\n    fs.readFile(pj, (er, data) => er ? this.done() : this.onPackageJson(pj, data));\n  }\n\n  onPackageJson(pj, data) {\n    try {\n      this.package = JSON.parse(data + '');\n    } catch (er) {\n      return this.done();\n    }\n\n    this.packageJsonCache.set(pj, this.package);\n    this.onPackage(this.package);\n  }\n\n  onPackage(pkg) {\n    // all deps are bundled if we got here as a child.\n    // otherwise, only bundle bundledDeps\n    // Get a unique-ified array with a short-lived Set\n    const bdRaw = this.parent ? Object.keys(pkg.dependencies || {}).concat(Object.keys(pkg.optionalDependencies || {})) : pkg.bundleDependencies || pkg.bundledDependencies || [];\n    const bd = Array.from(new Set(Array.isArray(bdRaw) ? bdRaw : Object.keys(bdRaw)));\n    if (!bd.length) return this.done();\n    this.bundle = bd;\n    const nm = this.path + '/node_modules';\n    this.readModules();\n  }\n\n  readModules() {\n    readdirNodeModules(this.path + '/node_modules', (er, nm) => er ? this.onReaddir([]) : this.onReaddir(nm));\n  }\n\n  onReaddir(nm) {\n    // keep track of what we have, in case children need it\n    this.node_modules = nm;\n    this.bundle.forEach(dep => this.childDep(dep));\n    if (this.children === 0) this.done();\n  }\n\n  childDep(dep) {\n    if (this.node_modules.indexOf(dep) !== -1 && !this.seen.has(dep)) {\n      this.seen.add(dep);\n      this.child(dep);\n    } else if (this.parent) {\n      this.parent.childDep(dep);\n    }\n  }\n\n  child(dep) {\n    const p = this.path + '/node_modules/' + dep;\n    this.children += 1;\n    const child = new BundleWalker({\n      path: p,\n      parent: this\n    });\n    child.on('done', _ => {\n      if (--this.children === 0) this.done();\n    });\n    child.start();\n  }\n\n}\n\nclass BundleWalkerSync extends BundleWalker {\n  constructor(opt) {\n    super(opt);\n  }\n\n  start() {\n    super.start();\n    this.done();\n    return this;\n  }\n\n  readPackageJson(pj) {\n    try {\n      this.onPackageJson(pj, fs.readFileSync(pj));\n    } catch (er) {}\n\n    return this;\n  }\n\n  readModules() {\n    try {\n      this.onReaddir(readdirNodeModulesSync(this.path + '/node_modules'));\n    } catch (er) {\n      this.onReaddir([]);\n    }\n  }\n\n  child(dep) {\n    new BundleWalkerSync({\n      path: this.path + '/node_modules/' + dep,\n      parent: this\n    }).start();\n  }\n\n}\n\nconst readdirNodeModules = (nm, cb) => {\n  fs.readdir(nm, (er, set) => {\n    if (er) cb(er);else {\n      const scopes = set.filter(f => /^@/.test(f));\n      if (!scopes.length) cb(null, set);else {\n        const unscoped = set.filter(f => !/^@/.test(f));\n        let count = scopes.length;\n        scopes.forEach(scope => {\n          fs.readdir(nm + '/' + scope, (er, pkgs) => {\n            if (er || !pkgs.length) unscoped.push(scope);else unscoped.push.apply(unscoped, pkgs.map(p => scope + '/' + p));\n            if (--count === 0) cb(null, unscoped);\n          });\n        });\n      }\n    }\n  });\n};\n\nconst readdirNodeModulesSync = nm => {\n  const set = fs.readdirSync(nm);\n  const unscoped = set.filter(f => !/^@/.test(f));\n  const scopes = set.filter(f => /^@/.test(f)).map(scope => {\n    try {\n      const pkgs = fs.readdirSync(nm + '/' + scope);\n      return pkgs.length ? pkgs.map(p => scope + '/' + p) : [scope];\n    } catch (er) {\n      return [scope];\n    }\n  }).reduce((a, b) => a.concat(b), []);\n  return unscoped.concat(scopes);\n};\n\nconst walk = (options, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new BundleWalker(options).on('done', resolve).on('error', reject).start();\n  });\n  return callback ? p.then(res => callback(null, res), callback) : p;\n};\n\nconst walkSync = options => {\n  return new BundleWalkerSync(options).start().result;\n};\n\nmodule.exports = walk;\nwalk.sync = walkSync;\nwalk.BundleWalker = BundleWalker;\nwalk.BundleWalkerSync = BundleWalkerSync;","map":null,"metadata":{},"sourceType":"script"}