{"ast":null,"code":"'use strict';\n\nconst assert = require('assert');\n\nconst Buffer = require('buffer').Buffer;\n\nconst realZlib = require('zlib');\n\nconst constants = exports.constants = require('./constants.js');\n\nconst Minipass = require('minipass');\n\nconst OriginalBufferConcat = Buffer.concat;\n\nclass ZlibError extends Error {\n  constructor(err) {\n    super('zlib: ' + err.message);\n    this.code = err.code;\n    this.errno = err.errno;\n    /* istanbul ignore if */\n\n    if (!this.code) this.code = 'ZLIB_ERROR';\n    this.message = 'zlib: ' + err.message;\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  get name() {\n    return 'ZlibError';\n  }\n\n} // the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\n\nconst _opts = Symbol('opts');\n\nconst _flushFlag = Symbol('flushFlag');\n\nconst _finishFlushFlag = Symbol('finishFlushFlag');\n\nconst _fullFlushFlag = Symbol('fullFlushFlag');\n\nconst _handle = Symbol('handle');\n\nconst _onError = Symbol('onError');\n\nconst _sawError = Symbol('sawError');\n\nconst _level = Symbol('level');\n\nconst _strategy = Symbol('strategy');\n\nconst _ended = Symbol('ended');\n\nconst _defaultFullFlush = Symbol('_defaultFullFlush');\n\nclass ZlibBase extends Minipass {\n  constructor(opts, mode) {\n    if (!opts || typeof opts !== 'object') throw new TypeError('invalid options for ZlibBase constructor');\n    super(opts);\n    this[_ended] = false;\n    this[_opts] = opts;\n    this[_flushFlag] = opts.flush;\n    this[_finishFlushFlag] = opts.finishFlush; // this will throw if any options are invalid for the class selected\n\n    try {\n      this[_handle] = new realZlib[mode](opts);\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er);\n    }\n\n    this[_onError] = err => {\n      this[_sawError] = true; // there is no way to cleanly recover.\n      // continuing only obscures problems.\n\n      this.close();\n      this.emit('error', err);\n    };\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)));\n\n    this.once('end', () => this.close);\n  }\n\n  close() {\n    if (this[_handle]) {\n      this[_handle].close();\n\n      this[_handle] = null;\n      this.emit('close');\n    }\n  }\n\n  reset() {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed');\n      return this[_handle].reset();\n    }\n  }\n\n  flush(flushFlag) {\n    if (this.ended) return;\n    if (typeof flushFlag !== 'number') flushFlag = this[_fullFlushFlag];\n    this.write(Object.assign(Buffer.alloc(0), {\n      [_flushFlag]: flushFlag\n    }));\n  }\n\n  end(chunk, encoding, cb) {\n    if (chunk) this.write(chunk, encoding);\n    this.flush(this[_finishFlushFlag]);\n    this[_ended] = true;\n    return super.end(null, null, cb);\n  }\n\n  get ended() {\n    return this[_ended];\n  }\n\n  write(chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);\n    if (this[_sawError]) return;\n    assert(this[_handle], 'zlib binding closed'); // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n\n    const nativeHandle = this[_handle]._handle;\n    const originalNativeClose = nativeHandle.close;\n\n    nativeHandle.close = () => {};\n\n    const originalClose = this[_handle].close;\n\n    this[_handle].close = () => {}; // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n\n\n    Buffer.concat = args => args;\n\n    let result;\n\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number' ? chunk[_flushFlag] : this[_flushFlag];\n      result = this[_handle]._processChunk(chunk, flushFlag); // if we don't throw, reset it back how it was\n\n      Buffer.concat = OriginalBufferConcat;\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat;\n\n      this[_onError](new ZlibError(err));\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle;\n        nativeHandle.close = originalNativeClose;\n        this[_handle].close = originalClose; // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n\n        this[_handle].removeAllListeners('error');\n      }\n    }\n\n    let writeReturn;\n\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = super.write(Buffer.from(result[0]));\n\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = super.write(result[i]);\n        }\n      } else {\n        writeReturn = super.write(Buffer.from(result));\n      }\n    }\n\n    if (cb) cb();\n    return writeReturn;\n  }\n\n}\n\nclass Zlib extends ZlibBase {\n  constructor(opts, mode) {\n    opts = opts || {};\n    opts.flush = opts.flush || constants.Z_NO_FLUSH;\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH;\n    super(opts, mode);\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH;\n    this[_level] = opts.level;\n    this[_strategy] = opts.strategy;\n  }\n\n  params(level, strategy) {\n    if (this[_sawError]) return;\n    if (!this[_handle]) throw new Error('cannot switch params when binding is closed'); // no way to test this without also not supporting params at all\n\n    /* istanbul ignore if */\n\n    if (!this[_handle].params) throw new Error('not supported in this implementation');\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH);\n      assert(this[_handle], 'zlib binding closed'); // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n\n      const origFlush = this[_handle].flush;\n\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag);\n        cb();\n      };\n\n      try {\n        this[_handle].params(level, strategy);\n      } finally {\n        this[_handle].flush = origFlush;\n      }\n      /* istanbul ignore else */\n\n\n      if (this[_handle]) {\n        this[_level] = level;\n        this[_strategy] = strategy;\n      }\n    }\n  }\n\n} // minimal 2-byte header\n\n\nclass Deflate extends Zlib {\n  constructor(opts) {\n    super(opts, 'Deflate');\n  }\n\n}\n\nclass Inflate extends Zlib {\n  constructor(opts) {\n    super(opts, 'Inflate');\n  }\n\n} // gzip - bigger header, same deflate compression\n\n\nclass Gzip extends Zlib {\n  constructor(opts) {\n    super(opts, 'Gzip');\n  }\n\n}\n\nclass Gunzip extends Zlib {\n  constructor(opts) {\n    super(opts, 'Gunzip');\n  }\n\n} // raw - no header\n\n\nclass DeflateRaw extends Zlib {\n  constructor(opts) {\n    super(opts, 'DeflateRaw');\n  }\n\n}\n\nclass InflateRaw extends Zlib {\n  constructor(opts) {\n    super(opts, 'InflateRaw');\n  }\n\n} // auto-detect header.\n\n\nclass Unzip extends Zlib {\n  constructor(opts) {\n    super(opts, 'Unzip');\n  }\n\n}\n\nclass Brotli extends ZlibBase {\n  constructor(opts, mode) {\n    opts = opts || {};\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;\n    super(opts, mode);\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;\n  }\n\n}\n\nclass BrotliCompress extends Brotli {\n  constructor(opts) {\n    super(opts, 'BrotliCompress');\n  }\n\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor(opts) {\n    super(opts, 'BrotliDecompress');\n  }\n\n}\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n/* istanbul ignore else */\n\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress;\n  exports.BrotliDecompress = BrotliDecompress;\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor() {\n      throw new Error('Brotli is not supported in this version of Node.js');\n    }\n\n  };\n}","map":null,"metadata":{},"sourceType":"script"}