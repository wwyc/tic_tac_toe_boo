{"ast":null,"code":"'use strict'; // Do a two-pass walk, first to get the list of packages that need to be\n// bundled, then again to get the actual files and folders.\n// Keep a cache of node_modules content and package.json data, so that the\n// second walk doesn't have to re-do all the same work.\n\nconst bundleWalk = require('npm-bundled');\n\nconst BundleWalker = bundleWalk.BundleWalker;\nconst BundleWalkerSync = bundleWalk.BundleWalkerSync;\n\nconst ignoreWalk = require('ignore-walk');\n\nconst IgnoreWalker = ignoreWalk.Walker;\nconst IgnoreWalkerSync = ignoreWalk.WalkerSync;\nconst rootBuiltinRules = Symbol('root-builtin-rules');\nconst packageNecessaryRules = Symbol('package-necessary-rules');\n\nconst path = require('path');\n\nconst defaultRules = ['.npmignore', '.gitignore', '**/.git', '**/.svn', '**/.hg', '**/CVS', '**/.git/**', '**/.svn/**', '**/.hg/**', '**/CVS/**', '/.lock-wscript', '/.wafpickle-*', '/build/config.gypi', 'npm-debug.log', '**/.npmrc', '.*.swp', '.DS_Store', '**/.DS_Store/**', '._*', '**/._*/**', '*.orig', '/package-lock.json', '/yarn.lock', 'archived-packages/**', 'core', '!core/', '!**/core/', '*.core', '*.vgcore', 'vgcore.*', 'core.+([0-9])']; // There may be others, but :?|<> are handled by node-tar\n\nconst nameIsBadForWindows = file => /\\*/.test(file); // a decorator that applies our custom rules to an ignore walker\n\n\nconst npmWalker = Class => class Walker extends Class {\n  constructor(opt) {\n    opt = opt || {}; // the order in which rules are applied.\n\n    opt.ignoreFiles = [rootBuiltinRules, 'package.json', '.npmignore', '.gitignore', packageNecessaryRules];\n    opt.includeEmpty = false;\n    opt.path = opt.path || process.cwd();\n    const dirName = path.basename(opt.path);\n    const parentName = path.basename(path.dirname(opt.path));\n    opt.follow = dirName === 'node_modules' || parentName === 'node_modules' && /^@/.test(dirName);\n    super(opt); // ignore a bunch of things by default at the root level.\n    // also ignore anything in node_modules, except bundled dependencies\n\n    if (!this.parent) {\n      this.bundled = opt.bundled || [];\n      this.bundledScopes = Array.from(new Set(this.bundled.filter(f => /^@/.test(f)).map(f => f.split('/')[0])));\n      const rules = defaultRules.join('\\n') + '\\n';\n      this.packageJsonCache = opt.packageJsonCache || new Map();\n      super.onReadIgnoreFile(rootBuiltinRules, rules, _ => _);\n    } else {\n      this.bundled = [];\n      this.bundledScopes = [];\n      this.packageJsonCache = this.parent.packageJsonCache;\n    }\n  }\n\n  onReaddir(entries) {\n    if (!this.parent) {\n      entries = entries.filter(e => e !== '.git' && !(e === 'node_modules' && this.bundled.length === 0));\n    }\n\n    return super.onReaddir(entries);\n  }\n\n  filterEntry(entry, partial) {\n    // get the partial path from the root of the walk\n    const p = this.path.substr(this.root.length + 1);\n    const pkgre = /^node_modules\\/(@[^\\/]+\\/?[^\\/]+|[^\\/]+)(\\/.*)?$/;\n    const isRoot = !this.parent;\n    const pkg = isRoot && pkgre.test(entry) ? entry.replace(pkgre, '$1') : null;\n    const rootNM = isRoot && entry === 'node_modules';\n    const rootPJ = isRoot && entry === 'package.json';\n    return (// if we're in a bundled package, check with the parent.\n      /^node_modules($|\\/)/i.test(p) ? this.parent.filterEntry(this.basename + '/' + entry, partial) // if package is bundled, all files included\n      // also include @scope dirs for bundled scoped deps\n      // they'll be ignored if no files end up in them.\n      // However, this only matters if we're in the root.\n      // node_modules folders elsewhere, like lib/node_modules,\n      // should be included normally unless ignored.\n      : pkg ? -1 !== this.bundled.indexOf(pkg) || -1 !== this.bundledScopes.indexOf(pkg) // only walk top node_modules if we want to bundle something\n      : rootNM ? !!this.bundled.length // always include package.json at the root.\n      : rootPJ ? true // otherwise, follow ignore-walk's logic\n      : super.filterEntry(entry, partial)\n    );\n  }\n\n  filterEntries() {\n    if (this.ignoreRules['package.json']) this.ignoreRules['.gitignore'] = this.ignoreRules['.npmignore'] = null;else if (this.ignoreRules['.npmignore']) this.ignoreRules['.gitignore'] = null;\n    this.filterEntries = super.filterEntries;\n    super.filterEntries();\n  }\n\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    if (this.packageJsonCache.has(ig)) this.onPackageJson(ig, this.packageJsonCache.get(ig), then);else super.addIgnoreFile(file, then);\n  }\n\n  onPackageJson(ig, pkg, then) {\n    this.packageJsonCache.set(ig, pkg); // if there's a bin, browser or main, make sure we don't ignore it\n    // also, don't ignore the package.json itself!\n    //\n    // Weird side-effect of this: a readme (etc) file will be included\n    // if it exists anywhere within a folder with a package.json file.\n    // The original intent was only to include these files in the root,\n    // but now users in the wild are dependent on that behavior for\n    // localized documentation and other use cases.  Adding a `/` to\n    // these rules, while tempting and arguably more \"correct\", is a\n    // breaking change.\n\n    const rules = [pkg.browser ? '!' + pkg.browser : '', pkg.main ? '!' + pkg.main : '', '!package.json', '!npm-shrinkwrap.json', '!@(readme|copying|license|licence|notice|changes|changelog|history){,.*[^~$]}'];\n    if (pkg.bin) if (typeof pkg.bin === \"object\") for (const key in pkg.bin) rules.push('!' + pkg.bin[key]);else rules.push('!' + pkg.bin);\n    const data = rules.filter(f => f).join('\\n') + '\\n';\n    super.onReadIgnoreFile(packageNecessaryRules, data, _ => _);\n    if (Array.isArray(pkg.files)) super.onReadIgnoreFile('package.json', '*\\n' + pkg.files.map(f => '!' + f + '\\n!' + f.replace(/\\/+$/, '') + '/**').join('\\n') + '\\n', then);else then();\n  } // override parent stat function to completely skip any filenames\n  // that will break windows entirely.\n  // XXX(isaacs) Next major version should make this an error instead.\n\n\n  stat(entry, file, dir, then) {\n    if (nameIsBadForWindows(entry)) then();else super.stat(entry, file, dir, then);\n  } // override parent onstat function to nix all symlinks\n\n\n  onstat(st, entry, file, dir, then) {\n    if (st.isSymbolicLink()) then();else super.onstat(st, entry, file, dir, then);\n  }\n\n  onReadIgnoreFile(file, data, then) {\n    if (file === 'package.json') try {\n      const ig = path.resolve(this.path, file);\n      this.onPackageJson(ig, JSON.parse(data), then);\n    } catch (er) {\n      // ignore package.json files that are not json\n      then();\n    } else super.onReadIgnoreFile(file, data, then);\n  }\n\n  sort(a, b) {\n    return sort(a, b);\n  }\n\n};\n\nclass Walker extends npmWalker(IgnoreWalker) {\n  walker(entry, then) {\n    new Walker(this.walkerOpt(entry)).on('done', then).start();\n  }\n\n}\n\nclass WalkerSync extends npmWalker(IgnoreWalkerSync) {\n  walker(entry, then) {\n    new WalkerSync(this.walkerOpt(entry)).start();\n    then();\n  }\n\n}\n\nconst walk = (options, callback) => {\n  options = options || {};\n  const p = new Promise((resolve, reject) => {\n    const bw = new BundleWalker(options);\n    bw.on('done', bundled => {\n      options.bundled = bundled;\n      options.packageJsonCache = bw.packageJsonCache;\n      new Walker(options).on('done', resolve).on('error', reject).start();\n    });\n    bw.start();\n  });\n  return callback ? p.then(res => callback(null, res), callback) : p;\n};\n\nconst walkSync = options => {\n  options = options || {};\n  const bw = new BundleWalkerSync(options).start();\n  options.bundled = bw.result;\n  options.packageJsonCache = bw.packageJsonCache;\n  const walker = new WalkerSync(options);\n  walker.start();\n  return walker.result;\n}; // optimize for compressibility\n// extname, then basename, then locale alphabetically\n// https://twitter.com/isntitvacant/status/1131094910923231232\n\n\nconst sort = (a, b) => {\n  const exta = path.extname(a).toLowerCase();\n  const extb = path.extname(b).toLowerCase();\n  const basea = path.basename(a).toLowerCase();\n  const baseb = path.basename(b).toLowerCase();\n  return exta.localeCompare(extb) || basea.localeCompare(baseb) || a.localeCompare(b);\n};\n\nmodule.exports = walk;\nwalk.sync = walkSync;\nwalk.Walker = Walker;\nwalk.WalkerSync = WalkerSync;","map":null,"metadata":{},"sourceType":"script"}