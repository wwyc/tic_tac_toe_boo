{"ast":null,"code":"var binary = require('node-pre-gyp');\n\nvar path = require('path');\n\nvar binding_path = binary.find(path.resolve(path.join(__dirname, '../package.json')));\n\nvar binding = require(binding_path);\n\nvar sqlite3 = module.exports = exports = binding;\n\nvar EventEmitter = require('events').EventEmitter;\n\nfunction normalizeMethod(fn) {\n  return function (sql) {\n    var errBack;\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    if (typeof args[args.length - 1] === 'function') {\n      var callback = args[args.length - 1];\n\n      errBack = function (err) {\n        if (err) {\n          callback(err);\n        }\n      };\n    }\n\n    var statement = new Statement(this, sql, errBack);\n    return fn.call(this, statement, args);\n  };\n}\n\nfunction inherits(target, source) {\n  for (var k in source.prototype) target.prototype[k] = source.prototype[k];\n}\n\nsqlite3.cached = {\n  Database: function (file, a, b) {\n    if (file === '' || file === ':memory:') {\n      // Don't cache special databases.\n      return new Database(file, a, b);\n    }\n\n    var db;\n    file = path.resolve(file);\n\n    function cb() {\n      callback.call(db, null);\n    }\n\n    if (!sqlite3.cached.objects[file]) {\n      db = sqlite3.cached.objects[file] = new Database(file, a, b);\n    } else {\n      // Make sure the callback is called.\n      db = sqlite3.cached.objects[file];\n      var callback = typeof a === 'number' ? b : a;\n\n      if (typeof callback === 'function') {\n        if (db.open) process.nextTick(cb);else db.once('open', cb);\n      }\n    }\n\n    return db;\n  },\n  objects: {}\n};\nvar Database = sqlite3.Database;\nvar Statement = sqlite3.Statement;\nvar Backup = sqlite3.Backup;\ninherits(Database, EventEmitter);\ninherits(Statement, EventEmitter);\ninherits(Backup, EventEmitter); // Database#prepare(sql, [bind1, bind2, ...], [callback])\n\nDatabase.prototype.prepare = normalizeMethod(function (statement, params) {\n  return params.length ? statement.bind.apply(statement, params) : statement;\n}); // Database#run(sql, [bind1, bind2, ...], [callback])\n\nDatabase.prototype.run = normalizeMethod(function (statement, params) {\n  statement.run.apply(statement, params).finalize();\n  return this;\n}); // Database#get(sql, [bind1, bind2, ...], [callback])\n\nDatabase.prototype.get = normalizeMethod(function (statement, params) {\n  statement.get.apply(statement, params).finalize();\n  return this;\n}); // Database#all(sql, [bind1, bind2, ...], [callback])\n\nDatabase.prototype.all = normalizeMethod(function (statement, params) {\n  statement.all.apply(statement, params).finalize();\n  return this;\n}); // Database#each(sql, [bind1, bind2, ...], [callback], [complete])\n\nDatabase.prototype.each = normalizeMethod(function (statement, params) {\n  statement.each.apply(statement, params).finalize();\n  return this;\n});\nDatabase.prototype.map = normalizeMethod(function (statement, params) {\n  statement.map.apply(statement, params).finalize();\n  return this;\n}); // Database#backup(filename, [callback])\n// Database#backup(filename, destName, sourceName, filenameIsDest, [callback])\n\nDatabase.prototype.backup = function () {\n  var backup;\n\n  if (arguments.length <= 2) {\n    // By default, we write the main database out to the main database of the named file.\n    // This is the most likely use of the backup api.\n    backup = new Backup(this, arguments[0], 'main', 'main', true, arguments[1]);\n  } else {\n    // Otherwise, give the user full control over the sqlite3_backup_init arguments.\n    backup = new Backup(this, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);\n  } // Per the sqlite docs, exclude the following errors as non-fatal by default.\n\n\n  backup.retryErrors = [sqlite3.BUSY, sqlite3.LOCKED];\n  return backup;\n};\n\nStatement.prototype.map = function () {\n  var params = Array.prototype.slice.call(arguments);\n  var callback = params.pop();\n  params.push(function (err, rows) {\n    if (err) return callback(err);\n    var result = {};\n\n    if (rows.length) {\n      var keys = Object.keys(rows[0]),\n          key = keys[0];\n\n      if (keys.length > 2) {\n        // Value is an object\n        for (var i = 0; i < rows.length; i++) {\n          result[rows[i][key]] = rows[i];\n        }\n      } else {\n        var value = keys[1]; // Value is a plain value\n\n        for (i = 0; i < rows.length; i++) {\n          result[rows[i][key]] = rows[i][value];\n        }\n      }\n    }\n\n    callback(err, result);\n  });\n  return this.all.apply(this, params);\n};\n\nvar isVerbose = false;\nvar supportedEvents = ['trace', 'profile', 'insert', 'update', 'delete'];\n\nDatabase.prototype.addListener = Database.prototype.on = function (type) {\n  var val = EventEmitter.prototype.addListener.apply(this, arguments);\n\n  if (supportedEvents.indexOf(type) >= 0) {\n    this.configure(type, true);\n  }\n\n  return val;\n};\n\nDatabase.prototype.removeListener = function (type) {\n  var val = EventEmitter.prototype.removeListener.apply(this, arguments);\n\n  if (supportedEvents.indexOf(type) >= 0 && !this._events[type]) {\n    this.configure(type, false);\n  }\n\n  return val;\n};\n\nDatabase.prototype.removeAllListeners = function (type) {\n  var val = EventEmitter.prototype.removeAllListeners.apply(this, arguments);\n\n  if (supportedEvents.indexOf(type) >= 0) {\n    this.configure(type, false);\n  }\n\n  return val;\n}; // Save the stack trace over EIO callbacks.\n\n\nsqlite3.verbose = function () {\n  if (!isVerbose) {\n    var trace = require('./trace');\n\n    ['prepare', 'get', 'run', 'all', 'each', 'map', 'close', 'exec'].forEach(function (name) {\n      trace.extendTrace(Database.prototype, name);\n    });\n    ['bind', 'get', 'run', 'all', 'each', 'map', 'reset', 'finalize'].forEach(function (name) {\n      trace.extendTrace(Statement.prototype, name);\n    });\n    isVerbose = true;\n  }\n\n  return this;\n};","map":null,"metadata":{},"sourceType":"script"}