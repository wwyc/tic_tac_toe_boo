{"ast":null,"code":"'use strict';\n\nconst Buffer = require('./buffer.js'); // XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n// tar -t\n\n\nconst hlo = require('./high-level-opt.js');\n\nconst Parser = require('./parse.js');\n\nconst fs = require('fs');\n\nconst fsm = require('fs-minipass');\n\nconst path = require('path');\n\nconst t = module.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function') cb = opt_, files = null, opt_ = {};else if (Array.isArray(opt_)) files = opt_, opt_ = {};\n  if (typeof files === 'function') cb = files, files = null;\n  if (!files) files = [];else files = Array.from(files);\n  const opt = hlo(opt_);\n  if (opt.sync && typeof cb === 'function') throw new TypeError('callback not supported for sync tar functions');\n  if (!opt.file && typeof cb === 'function') throw new TypeError('callback only supported with file option');\n  if (files.length) filesFilter(opt, files);\n  if (!opt.noResume) onentryFunction(opt);\n  return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list(opt);\n};\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry;\n  opt.onentry = onentry ? e => {\n    onentry(e);\n    e.resume();\n  } : e => e.resume();\n}; // construct a filter that limits the file entries listed\n// include child entries if a dir is included\n\n\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [f.replace(/\\/+$/, ''), true]));\n  const filter = opt.filter;\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.';\n    const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path.dirname(file), root);\n    map.set(file, ret);\n    return ret;\n  };\n\n  opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\\/+$/, '')) : file => mapHas(file.replace(/\\/+$/, ''));\n};\n\nconst listFileSync = opt => {\n  const p = list(opt);\n  const file = opt.file;\n  let threw = true;\n  let fd;\n\n  try {\n    const stat = fs.statSync(file);\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file));\n    } else {\n      let pos = 0;\n      const buf = Buffer.allocUnsafe(readSize);\n      fd = fs.openSync(file, 'r');\n\n      while (pos < stat.size) {\n        let bytesRead = fs.readSync(fd, buf, 0, readSize, pos);\n        pos += bytesRead;\n        p.write(buf.slice(0, bytesRead));\n      }\n\n      p.end();\n    }\n\n    threw = false;\n  } finally {\n    if (threw && fd) try {\n      fs.closeSync(fd);\n    } catch (er) {}\n  }\n};\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt);\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n  const file = opt.file;\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject);\n    parse.on('end', resolve);\n    fs.stat(file, (er, stat) => {\n      if (er) reject(er);else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        });\n        stream.on('error', reject);\n        stream.pipe(parse);\n      }\n    });\n  });\n  return cb ? p.then(cb, cb) : p;\n};\n\nconst list = opt => new Parser(opt);","map":null,"metadata":{},"sourceType":"script"}