{"ast":null,"code":"'use strict';\n\nconst Buffer = require('./buffer.js'); // A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\n\nclass PackJob {\n  constructor(path, absolute) {\n    this.path = path || './';\n    this.absolute = absolute;\n    this.entry = null;\n    this.stat = null;\n    this.readdir = null;\n    this.pending = false;\n    this.ignore = false;\n    this.piped = false;\n  }\n\n}\n\nconst MiniPass = require('minipass');\n\nconst zlib = require('minizlib');\n\nconst ReadEntry = require('./read-entry.js');\n\nconst WriteEntry = require('./write-entry.js');\n\nconst WriteEntrySync = WriteEntry.Sync;\nconst WriteEntryTar = WriteEntry.Tar;\n\nconst Yallist = require('yallist');\n\nconst EOF = Buffer.alloc(1024);\nconst ONSTAT = Symbol('onStat');\nconst ENDED = Symbol('ended');\nconst QUEUE = Symbol('queue');\nconst CURRENT = Symbol('current');\nconst PROCESS = Symbol('process');\nconst PROCESSING = Symbol('processing');\nconst PROCESSJOB = Symbol('processJob');\nconst JOBS = Symbol('jobs');\nconst JOBDONE = Symbol('jobDone');\nconst ADDFSENTRY = Symbol('addFSEntry');\nconst ADDTARENTRY = Symbol('addTarEntry');\nconst STAT = Symbol('stat');\nconst READDIR = Symbol('readdir');\nconst ONREADDIR = Symbol('onreaddir');\nconst PIPE = Symbol('pipe');\nconst ENTRY = Symbol('entry');\nconst ENTRYOPT = Symbol('entryOpt');\nconst WRITEENTRYCLASS = Symbol('writeEntryClass');\nconst WRITE = Symbol('write');\nconst ONDRAIN = Symbol('ondrain');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst warner = require('./warn-mixin.js');\n\nconst Pack = warner(class Pack extends MiniPass {\n  constructor(opt) {\n    super(opt);\n    opt = opt || Object.create(null);\n    this.opt = opt;\n    this.cwd = opt.cwd || process.cwd();\n    this.maxReadSize = opt.maxReadSize;\n    this.preservePaths = !!opt.preservePaths;\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.prefix = (opt.prefix || '').replace(/(\\\\|\\/)+$/, '');\n    this.linkCache = opt.linkCache || new Map();\n    this.statCache = opt.statCache || new Map();\n    this.readdirCache = opt.readdirCache || new Map();\n    this[WRITEENTRYCLASS] = WriteEntry;\n    if (typeof opt.onwarn === 'function') this.on('warn', opt.onwarn);\n    this.zip = null;\n\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object') opt.gzip = {};\n      this.zip = new zlib.Gzip(opt.gzip);\n      this.zip.on('data', chunk => super.write(chunk));\n      this.zip.on('end', _ => super.end());\n      this.zip.on('drain', _ => this[ONDRAIN]());\n      this.on('resume', _ => this.zip.resume());\n    } else this.on('drain', this[ONDRAIN]);\n\n    this.portable = !!opt.portable;\n    this.noDirRecurse = !!opt.noDirRecurse;\n    this.follow = !!opt.follow;\n    this.noMtime = !!opt.noMtime;\n    this.mtime = opt.mtime || null;\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true;\n    this[QUEUE] = new Yallist();\n    this[JOBS] = 0;\n    this.jobs = +opt.jobs || 4;\n    this[PROCESSING] = false;\n    this[ENDED] = false;\n  }\n\n  [WRITE](chunk) {\n    return super.write(chunk);\n  }\n\n  add(path) {\n    this.write(path);\n    return this;\n  }\n\n  end(path) {\n    if (path) this.write(path);\n    this[ENDED] = true;\n    this[PROCESS]();\n    return this;\n  }\n\n  write(path) {\n    if (this[ENDED]) throw new Error('write after end');\n    if (path instanceof ReadEntry) this[ADDTARENTRY](path);else this[ADDFSENTRY](path);\n    return this.flowing;\n  }\n\n  [ADDTARENTRY](p) {\n    const absolute = path.resolve(this.cwd, p.path);\n    if (this.prefix) p.path = this.prefix + '/' + p.path.replace(/^\\.(\\/+|$)/, ''); // in this case, we don't have to wait for the stat\n\n    if (!this.filter(p.path, p)) p.resume();else {\n      const job = new PackJob(p.path, absolute, false);\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));\n      job.entry.on('end', _ => this[JOBDONE](job));\n      this[JOBS] += 1;\n      this[QUEUE].push(job);\n    }\n    this[PROCESS]();\n  }\n\n  [ADDFSENTRY](p) {\n    const absolute = path.resolve(this.cwd, p);\n    if (this.prefix) p = this.prefix + '/' + p.replace(/^\\.(\\/+|$)/, '');\n    this[QUEUE].push(new PackJob(p, absolute));\n    this[PROCESS]();\n  }\n\n  [STAT](job) {\n    job.pending = true;\n    this[JOBS] += 1;\n    const stat = this.follow ? 'stat' : 'lstat';\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false;\n      this[JOBS] -= 1;\n      if (er) this.emit('error', er);else this[ONSTAT](job, stat);\n    });\n  }\n\n  [ONSTAT](job, stat) {\n    this.statCache.set(job.absolute, stat);\n    job.stat = stat; // now we have the stat, we can filter it.\n\n    if (!this.filter(job.path, stat)) job.ignore = true;\n    this[PROCESS]();\n  }\n\n  [READDIR](job) {\n    job.pending = true;\n    this[JOBS] += 1;\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false;\n      this[JOBS] -= 1;\n      if (er) return this.emit('error', er);\n      this[ONREADDIR](job, entries);\n    });\n  }\n\n  [ONREADDIR](job, entries) {\n    this.readdirCache.set(job.absolute, entries);\n    job.readdir = entries;\n    this[PROCESS]();\n  }\n\n  [PROCESS]() {\n    if (this[PROCESSING]) return;\n    this[PROCESSING] = true;\n\n    for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {\n      this[PROCESSJOB](w.value);\n\n      if (w.value.ignore) {\n        const p = w.next;\n        this[QUEUE].removeNode(w);\n        w.next = p;\n      }\n    }\n\n    this[PROCESSING] = false;\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip) this.zip.end(EOF);else {\n        super.write(EOF);\n        super.end();\n      }\n    }\n  }\n\n  get [CURRENT]() {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;\n  }\n\n  [JOBDONE](job) {\n    this[QUEUE].shift();\n    this[JOBS] -= 1;\n    this[PROCESS]();\n  }\n\n  [PROCESSJOB](job) {\n    if (job.pending) return;\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped) this[PIPE](job);\n      return;\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute)) this[ONSTAT](job, this.statCache.get(job.absolute));else this[STAT](job);\n    }\n\n    if (!job.stat) return; // filtered out!\n\n    if (job.ignore) return;\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute)) this[ONREADDIR](job, this.readdirCache.get(job.absolute));else this[READDIR](job);\n      if (!job.readdir) return;\n    } // we know it doesn't have an entry, because that got checked above\n\n\n    job.entry = this[ENTRY](job);\n\n    if (!job.entry) {\n      job.ignore = true;\n      return;\n    }\n\n    if (job === this[CURRENT] && !job.piped) this[PIPE](job);\n  }\n\n  [ENTRYOPT](job) {\n    return {\n      onwarn: (msg, data) => {\n        this.warn(msg, data);\n      },\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime\n    };\n  }\n\n  [ENTRY](job) {\n    this[JOBS] += 1;\n\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on('end', () => this[JOBDONE](job)).on('error', er => this.emit('error', er));\n    } catch (er) {\n      this.emit('error', er);\n    }\n  }\n\n  [ONDRAIN]() {\n    if (this[CURRENT] && this[CURRENT].entry) this[CURRENT].entry.resume();\n  } // like .pipe() but using super, because our write() is special\n\n\n  [PIPE](job) {\n    job.piped = true;\n    if (job.readdir) job.readdir.forEach(entry => {\n      const p = this.prefix ? job.path.slice(this.prefix.length + 1) || './' : job.path;\n      const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n      this[ADDFSENTRY](base + entry);\n    });\n    const source = job.entry;\n    const zip = this.zip;\n    if (zip) source.on('data', chunk => {\n      if (!zip.write(chunk)) source.pause();\n    });else source.on('data', chunk => {\n      if (!super.write(chunk)) source.pause();\n    });\n  }\n\n  pause() {\n    if (this.zip) this.zip.pause();\n    return super.pause();\n  }\n\n});\n\nclass PackSync extends Pack {\n  constructor(opt) {\n    super(opt);\n    this[WRITEENTRYCLASS] = WriteEntrySync;\n  } // pause/resume are no-ops in sync streams.\n\n\n  pause() {}\n\n  resume() {}\n\n  [STAT](job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync';\n    this[ONSTAT](job, fs[stat](job.absolute));\n  }\n\n  [READDIR](job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute));\n  } // gotta get it all in this tick\n\n\n  [PIPE](job) {\n    const source = job.entry;\n    const zip = this.zip;\n    if (job.readdir) job.readdir.forEach(entry => {\n      const p = this.prefix ? job.path.slice(this.prefix.length + 1) || './' : job.path;\n      const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n      this[ADDFSENTRY](base + entry);\n    });\n    if (zip) source.on('data', chunk => {\n      zip.write(chunk);\n    });else source.on('data', chunk => {\n      super[WRITE](chunk);\n    });\n  }\n\n}\n\nPack.Sync = PackSync;\nmodule.exports = Pack;","map":null,"metadata":{},"sourceType":"script"}