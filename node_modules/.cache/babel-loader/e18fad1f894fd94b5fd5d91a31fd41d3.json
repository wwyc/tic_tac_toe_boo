{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst EE = require('events').EventEmitter;\n\nconst Minimatch = require('minimatch').Minimatch;\n\nclass Walker extends EE {\n  constructor(opts) {\n    opts = opts || {};\n    super(opts);\n    this.path = opts.path || process.cwd();\n    this.basename = path.basename(this.path);\n    this.ignoreFiles = opts.ignoreFiles || ['.ignore'];\n    this.ignoreRules = {};\n    this.parent = opts.parent || null;\n    this.includeEmpty = !!opts.includeEmpty;\n    this.root = this.parent ? this.parent.root : this.path;\n    this.follow = !!opts.follow;\n    this.result = this.parent ? this.parent.result : new Set();\n    this.entries = null;\n    this.sawError = false;\n  }\n\n  sort(a, b) {\n    return a.localeCompare(b);\n  }\n\n  emit(ev, data) {\n    let ret = false;\n\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error') this.sawError = true;else if (ev === 'done' && !this.parent) {\n        data = Array.from(data).map(e => /^@/.test(e) ? \"./\".concat(e) : e).sort(this.sort);\n        this.result = data;\n      }\n      if (ev === 'error' && this.parent) ret = this.parent.emit('error', data);else ret = super.emit(ev, data);\n    }\n\n    return ret;\n  }\n\n  start() {\n    fs.readdir(this.path, (er, entries) => er ? this.emit('error', er) : this.onReaddir(entries));\n    return this;\n  }\n\n  isIgnoreFile(e) {\n    return e !== \".\" && e !== \"..\" && -1 !== this.ignoreFiles.indexOf(e);\n  }\n\n  onReaddir(entries) {\n    this.entries = entries;\n\n    if (entries.length === 0) {\n      if (this.includeEmpty) this.result.add(this.path.substr(this.root.length + 1));\n      this.emit('done', this.result);\n    } else {\n      const hasIg = this.entries.some(e => this.isIgnoreFile(e));\n      if (hasIg) this.addIgnoreFiles();else this.filterEntries();\n    }\n  }\n\n  addIgnoreFiles() {\n    const newIg = this.entries.filter(e => this.isIgnoreFile(e));\n    let igCount = newIg.length;\n\n    const then = _ => {\n      if (--igCount === 0) this.filterEntries();\n    };\n\n    newIg.forEach(e => this.addIgnoreFile(e, then));\n  }\n\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    fs.readFile(ig, 'utf8', (er, data) => er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then));\n  }\n\n  onReadIgnoreFile(file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true\n    };\n    const rules = data.split(/\\r?\\n/).filter(line => !/^#|^$/.test(line.trim())).map(r => new Minimatch(r, mmopt));\n    this.ignoreRules[file] = rules;\n    then();\n  }\n\n  filterEntries() {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry);\n      const passDir = this.filterEntry(entry, true);\n      return passFile || passDir ? [entry, passFile, passDir] : false;\n    }).filter(e => e); // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n\n    let entryCount = filtered.length;\n\n    if (entryCount === 0) {\n      this.emit('done', this.result);\n    } else {\n      const then = _ => {\n        if (--entryCount === 0) this.emit('done', this.result);\n      };\n\n      filtered.forEach(filt => {\n        const entry = filt[0];\n        const file = filt[1];\n        const dir = filt[2];\n        this.stat(entry, file, dir, then);\n      });\n    }\n  }\n\n  onstat(st, entry, file, dir, then) {\n    const abs = this.path + '/' + entry;\n\n    if (!st.isDirectory()) {\n      if (file) this.result.add(abs.substr(this.root.length + 1));\n      then();\n    } else {\n      // is a directory\n      if (dir) this.walker(entry, then);else then();\n    }\n  }\n\n  stat(entry, file, dir, then) {\n    const abs = this.path + '/' + entry;\n    fs[this.follow ? 'stat' : 'lstat'](abs, (er, st) => {\n      if (er) this.emit('error', er);else this.onstat(st, entry, file, dir, then);\n    });\n  }\n\n  walkerOpt(entry) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty\n    };\n  }\n\n  walker(entry, then) {\n    new Walker(this.walkerOpt(entry)).on('done', then).start();\n  }\n\n  filterEntry(entry, partial) {\n    let included = true; // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n\n    if (this.parent && this.parent.filterEntry) {\n      var pt = this.basename + \"/\" + entry;\n      included = this.parent.filterEntry(pt, partial);\n    }\n\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            const match = rule.match('/' + entry) || rule.match(entry) || !!partial && (rule.match('/' + entry + '/') || rule.match(entry + '/')) || !!partial && rule.negate && (rule.match('/' + entry, true) || rule.match(entry, true));\n            if (match) included = rule.negate;\n          }\n        });\n      }\n    });\n    return included;\n  }\n\n}\n\nclass WalkerSync extends Walker {\n  constructor(opt) {\n    super(opt);\n  }\n\n  start() {\n    this.onReaddir(fs.readdirSync(this.path));\n    return this;\n  }\n\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then);\n  }\n\n  stat(entry, file, dir, then) {\n    const abs = this.path + '/' + entry;\n    const st = fs[this.follow ? 'statSync' : 'lstatSync'](abs);\n    this.onstat(st, entry, file, dir, then);\n  }\n\n  walker(entry, then) {\n    new WalkerSync(this.walkerOpt(entry)).start();\n    then();\n  }\n\n}\n\nconst walk = (options, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(options).on('done', resolve).on('error', reject).start();\n  });\n  return callback ? p.then(res => callback(null, res), callback) : p;\n};\n\nconst walkSync = options => {\n  return new WalkerSync(options).start().result;\n};\n\nmodule.exports = walk;\nwalk.sync = walkSync;\nwalk.Walker = Walker;\nwalk.WalkerSync = WalkerSync;","map":null,"metadata":{},"sourceType":"script"}