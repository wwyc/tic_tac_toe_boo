{"ast":null,"code":"'use strict'; // parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nconst Buffer = require('./buffer.js');\n\nconst types = require('./types.js');\n\nconst pathModule = require('path').posix;\n\nconst large = require('./large-numbers.js');\n\nconst SLURP = Symbol('slurp');\nconst TYPE = Symbol('type');\n\nclass Header {\n  constructor(data, off, ex, gex) {\n    this.cksumValid = false;\n    this.needPax = false;\n    this.nullBlock = false;\n    this.block = null;\n    this.path = null;\n    this.mode = null;\n    this.uid = null;\n    this.gid = null;\n    this.size = null;\n    this.mtime = null;\n    this.cksum = null;\n    this[TYPE] = '0';\n    this.linkpath = null;\n    this.uname = null;\n    this.gname = null;\n    this.devmaj = 0;\n    this.devmin = 0;\n    this.atime = null;\n    this.ctime = null;\n    if (Buffer.isBuffer(data)) this.decode(data, off || 0, ex, gex);else if (data) this.set(data);\n  }\n\n  decode(buf, off, ex, gex) {\n    if (!off) off = 0;\n    if (!buf || !(buf.length >= off + 512)) throw new Error('need 512 bytes for header');\n    this.path = decString(buf, off, 100);\n    this.mode = decNumber(buf, off + 100, 8);\n    this.uid = decNumber(buf, off + 108, 8);\n    this.gid = decNumber(buf, off + 116, 8);\n    this.size = decNumber(buf, off + 124, 12);\n    this.mtime = decDate(buf, off + 136, 12);\n    this.cksum = decNumber(buf, off + 148, 12); // if we have extended or global extended headers, apply them now\n    // See https://github.com/npm/node-tar/pull/187\n\n    this[SLURP](ex);\n    this[SLURP](gex, true); // old tar versions marked dirs as a file with a trailing /\n\n    this[TYPE] = decString(buf, off + 156, 1);\n    if (this[TYPE] === '') this[TYPE] = '0';\n    if (this[TYPE] === '0' && this.path.substr(-1) === '/') this[TYPE] = '5'; // tar implementations sometimes incorrectly put the stat(dir).size\n    // as the size in the tarball, even though Directory entries are\n    // not able to have any body at all.  In the very rare chance that\n    // it actually DOES have a body, we weren't going to do anything with\n    // it anyway, and it'll just be a warning about an invalid header.\n\n    if (this[TYPE] === '5') this.size = 0;\n    this.linkpath = decString(buf, off + 157, 100);\n\n    if (buf.slice(off + 257, off + 265).toString() === 'ustar\\u000000') {\n      this.uname = decString(buf, off + 265, 32);\n      this.gname = decString(buf, off + 297, 32);\n      this.devmaj = decNumber(buf, off + 329, 8);\n      this.devmin = decNumber(buf, off + 337, 8);\n\n      if (buf[off + 475] !== 0) {\n        // definitely a prefix, definitely >130 chars.\n        const prefix = decString(buf, off + 345, 155);\n        this.path = prefix + '/' + this.path;\n      } else {\n        const prefix = decString(buf, off + 345, 130);\n        if (prefix) this.path = prefix + '/' + this.path;\n        this.atime = decDate(buf, off + 476, 12);\n        this.ctime = decDate(buf, off + 488, 12);\n      }\n    }\n\n    let sum = 8 * 0x20;\n\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i];\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i];\n    }\n\n    this.cksumValid = sum === this.cksum;\n    if (this.cksum === null && sum === 8 * 0x20) this.nullBlock = true;\n  }\n\n  [SLURP](ex, global) {\n    for (let k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined && !(global && k === 'path')) this[k] = ex[k];\n    }\n  }\n\n  encode(buf, off) {\n    if (!buf) {\n      buf = this.block = Buffer.alloc(512);\n      off = 0;\n    }\n\n    if (!off) off = 0;\n    if (!(buf.length >= off + 512)) throw new Error('need 512 bytes for header');\n    const prefixSize = this.ctime || this.atime ? 130 : 155;\n    const split = splitPrefix(this.path || '', prefixSize);\n    const path = split[0];\n    const prefix = split[1];\n    this.needPax = split[2];\n    this.needPax = encString(buf, off, 100, path) || this.needPax;\n    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;\n    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;\n    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;\n    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;\n    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;\n    buf[off + 156] = this[TYPE].charCodeAt(0);\n    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;\n    buf.write('ustar\\u000000', off + 257, 8);\n    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;\n    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;\n    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;\n    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;\n    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;\n    if (buf[off + 475] !== 0) this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;else {\n      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;\n      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;\n      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;\n    }\n    let sum = 8 * 0x20;\n\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i];\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i];\n    }\n\n    this.cksum = sum;\n    encNumber(buf, off + 148, 8, this.cksum);\n    this.cksumValid = true;\n    return this.needPax;\n  }\n\n  set(data) {\n    for (let i in data) {\n      if (data[i] !== null && data[i] !== undefined) this[i] = data[i];\n    }\n  }\n\n  get type() {\n    return types.name.get(this[TYPE]) || this[TYPE];\n  }\n\n  get typeKey() {\n    return this[TYPE];\n  }\n\n  set type(type) {\n    if (types.code.has(type)) this[TYPE] = types.code.get(type);else this[TYPE] = type;\n  }\n\n}\n\nconst splitPrefix = (p, prefixSize) => {\n  const pathSize = 100;\n  let pp = p;\n  let prefix = '';\n  let ret;\n  const root = pathModule.parse(p).root || '.';\n  if (Buffer.byteLength(pp) < pathSize) ret = [pp, prefix, false];else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp);\n    pp = pathModule.basename(pp);\n\n    do {\n      // both fit!\n      if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize) ret = [pp, prefix, false]; // prefix fits in prefix, but path doesn't fit in path\n      else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize) ret = [pp.substr(0, pathSize - 1), prefix, true];else {\n          // make path take a bit from prefix\n          pp = pathModule.join(pathModule.basename(prefix), pp);\n          prefix = pathModule.dirname(prefix);\n        }\n    } while (prefix !== root && !ret); // at this point, found no resolution, just truncate\n\n\n    if (!ret) ret = [p.substr(0, pathSize - 1), '', true];\n  }\n  return ret;\n};\n\nconst decString = (buf, off, size) => buf.slice(off, off + size).toString('utf8').replace(/\\0.*/, '');\n\nconst decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));\n\nconst numToDate = num => num === null ? null : new Date(num * 1000);\n\nconst decNumber = (buf, off, size) => buf[off] & 0x80 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);\n\nconst nanNull = value => isNaN(value) ? null : value;\n\nconst decSmallNumber = (buf, off, size) => nanNull(parseInt(buf.slice(off, off + size).toString('utf8').replace(/\\0.*$/, '').trim(), 8)); // the maximum encodable as a null-terminated octal, by field size\n\n\nconst MAXNUM = {\n  12: 0o77777777777,\n  8: 0o7777777\n};\n\nconst encNumber = (buf, off, size, number) => number === null ? false : number > MAXNUM[size] || number < 0 ? (large.encode(number, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number), false);\n\nconst encSmallNumber = (buf, off, size, number) => buf.write(octalString(number, size), off, size, 'ascii');\n\nconst octalString = (number, size) => padOctal(Math.floor(number).toString(8), size);\n\nconst padOctal = (string, size) => (string.length === size - 1 ? string : new Array(size - string.length - 1).join('0') + string + ' ') + '\\0';\n\nconst encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1000); // enough to fill the longest string we've got\n\n\nconst NULLS = new Array(156).join('\\0'); // pad with nulls, return true if it's longer or non-ascii\n\nconst encString = (buf, off, size, string) => string === null ? false : (buf.write(string + NULLS, off, size, 'utf8'), string.length !== Buffer.byteLength(string) || string.length > size);\n\nmodule.exports = Header;","map":null,"metadata":{},"sourceType":"script"}